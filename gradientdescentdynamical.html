<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gradient Descent as a Dynamical System</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400;1,500&family=JetBrains+Mono:wght@300;400;500&family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300;1,400&display=swap" rel="stylesheet">
<style>
  :root {
    --ink: #0f0e0b;
    --paper: #f5f0e8;
    --cream: #ece6d6;
    --rust: #b85c2c;
    --sage: #4a6741;
    --slate: #3a4a5c;
    --gold: #c9983a;
    --muted: #7a7060;
    --rule: #c8bfa8;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--paper);
    color: var(--ink);
    font-family: 'EB Garamond', serif;
    font-size: 18px;
    line-height: 1.7;
    padding: 0;
  }

  /* HEADER */
  .masthead {
    border-bottom: 3px double var(--ink);
    padding: 3rem 0 2rem;
    text-align: center;
    background: var(--cream);
    position: relative;
    overflow: hidden;
  }

  .masthead::before {
    content: '';
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(
      90deg,
      transparent,
      transparent 60px,
      rgba(0,0,0,0.02) 60px,
      rgba(0,0,0,0.02) 61px
    );
  }

  .journal-name {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 2rem;
  }

  .title {
    font-family: 'Cormorant Garamond', serif;
    font-size: clamp(2rem, 5vw, 3.6rem);
    font-weight: 300;
    line-height: 1.2;
    max-width: 820px;
    margin: 0 auto 1.5rem;
    padding: 0 2rem;
  }

  .subtitle {
    font-family: 'EB Garamond', serif;
    font-style: italic;
    font-size: 1.1rem;
    color: var(--muted);
    margin-bottom: 2rem;
  }

  .meta-row {
    display: flex;
    justify-content: center;
    gap: 3rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    letter-spacing: 0.1em;
    color: var(--muted);
    text-transform: uppercase;
  }

  /* LAYOUT */
  .paper-body {
    max-width: 900px;
    margin: 0 auto;
    padding: 3rem 2rem 6rem;
  }

  /* ABSTRACT */
  .abstract-box {
    border: 1px solid var(--rule);
    background: var(--cream);
    padding: 2rem 2.5rem;
    margin: 3rem 0;
    position: relative;
  }

  .abstract-box::before {
    content: 'Abstract';
    position: absolute;
    top: -0.6em;
    left: 2rem;
    background: var(--cream);
    padding: 0 0.5rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--muted);
  }

  /* SECTIONS */
  h2.section-head {
    font-family: 'Cormorant Garamond', serif;
    font-size: 1.8rem;
    font-weight: 400;
    margin: 3.5rem 0 1.2rem;
    padding-bottom: 0.4rem;
    border-bottom: 1px solid var(--rule);
    display: flex;
    align-items: baseline;
    gap: 1rem;
  }

  .sec-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    color: var(--rust);
    letter-spacing: 0.05em;
  }

  h3.subsec {
    font-family: 'EB Garamond', serif;
    font-size: 1.15rem;
    font-weight: 600;
    font-style: italic;
    margin: 2rem 0 0.7rem;
    color: var(--slate);
  }

  p { margin-bottom: 1.1rem; }

  /* MATH DISPLAY */
  .equation-block {
    background: var(--cream);
    border-left: 3px solid var(--rust);
    padding: 1.2rem 1.8rem;
    margin: 1.5rem 0;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.95rem;
    overflow-x: auto;
    position: relative;
  }

  .eq-label {
    position: absolute;
    right: 1.2rem;
    top: 50%;
    transform: translateY(-50%);
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    color: var(--muted);
  }

  .math-inline {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.88em;
    background: rgba(0,0,0,0.04);
    padding: 0.1em 0.35em;
    border-radius: 2px;
  }

  /* THEOREM BOXES */
  .theorem {
    border: 1px solid var(--slate);
    padding: 1.5rem 2rem;
    margin: 2rem 0;
    position: relative;
  }

  .theorem-label {
    position: absolute;
    top: -0.65em;
    left: 1.5rem;
    background: var(--paper);
    padding: 0 0.5rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.68rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--slate);
    font-weight: 500;
  }

  .theorem.highlight {
    border-color: var(--rust);
    background: rgba(184, 92, 44, 0.03);
  }
  .theorem.highlight .theorem-label { color: var(--rust); }

  /* FIGURE / CANVAS AREA */
  .figure-wrap {
    margin: 2.5rem 0;
    border: 1px solid var(--rule);
  }

  .figure-header {
    background: var(--ink);
    color: var(--paper);
    padding: 0.6rem 1.2rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
  }

  .fig-controls {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    padding: 0.8rem 1.2rem;
    background: var(--cream);
    border-bottom: 1px solid var(--rule);
    flex-wrap: wrap;
  }

  .ctrl-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    color: var(--muted);
    letter-spacing: 0.05em;
    white-space: nowrap;
  }

  input[type=range] {
    accent-color: var(--rust);
    width: 140px;
  }

  .ctrl-val {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.78rem;
    color: var(--rust);
    min-width: 3.5rem;
  }

  select {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    background: var(--paper);
    border: 1px solid var(--rule);
    padding: 0.2rem 0.4rem;
    color: var(--ink);
  }

  .btn {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    background: var(--ink);
    color: var(--paper);
    border: none;
    padding: 0.35rem 0.9rem;
    cursor: pointer;
    transition: background 0.15s;
  }
  .btn:hover { background: var(--rust); }
  .btn.secondary {
    background: transparent;
    color: var(--ink);
    border: 1px solid var(--rule);
  }
  .btn.secondary:hover { background: var(--cream); color: var(--ink); }

  canvas {
    display: block;
    width: 100%;
    background: #0d0d0d;
  }

  .figure-caption {
    padding: 0.8rem 1.2rem;
    font-style: italic;
    font-size: 0.88rem;
    color: var(--muted);
    border-top: 1px solid var(--rule);
    background: var(--cream);
  }

  .figure-caption strong {
    font-style: normal;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    color: var(--ink);
    letter-spacing: 0.05em;
  }

  /* TWO COLUMN */
  .two-col {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin: 2rem 0;
  }

  @media (max-width: 650px) {
    .two-col { grid-template-columns: 1fr; }
  }

  /* STATUS INDICATORS */
  .phase-indicator {
    display: inline-flex;
    align-items: center;
    gap: 0.4rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    padding: 0.25rem 0.7rem;
    border: 1px solid currentColor;
    border-radius: 2px;
  }
  .phase-stable { color: var(--sage); }
  .phase-critical { color: var(--gold); }
  .phase-diverge { color: var(--rust); }

  .dot { width: 7px; height: 7px; border-radius: 50%; background: currentColor; display: inline-block; }

  /* STAT GRID */
  .stats-row {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 1px;
    background: var(--rule);
    border: 1px solid var(--rule);
    margin: 1rem 0;
  }

  .stat-cell {
    background: var(--cream);
    padding: 0.8rem 1rem;
    text-align: center;
  }

  .stat-val {
    font-family: 'JetBrains Mono', monospace;
    font-size: 1.1rem;
    color: var(--rust);
    display: block;
  }

  .stat-name {
    font-size: 0.75rem;
    color: var(--muted);
    font-style: italic;
  }

  /* BIFURCATION SPECIFIC */
  #bifurcation-canvas {
    cursor: crosshair;
  }

  /* REFERENCES */
  .references {
    border-top: 2px solid var(--ink);
    margin-top: 4rem;
    padding-top: 2rem;
  }

  .ref-item {
    font-size: 0.88rem;
    padding: 0.3rem 0 0.3rem 2rem;
    text-indent: -2rem;
    color: var(--muted);
    border-bottom: 1px dotted var(--rule);
  }

  .ref-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    color: var(--ink);
    margin-right: 0.5rem;
  }

  /* SCROLL ANIMATION */
  .reveal {
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.6s ease, transform 0.6s ease;
  }
  .reveal.visible {
    opacity: 1;
    transform: none;
  }

  /* LIVE INDICATOR */
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }
  .live-dot {
    display: inline-block;
    width: 6px; height: 6px;
    border-radius: 50%;
    background: #4caf50;
    animation: pulse 1.5s infinite;
    margin-right: 0.4rem;
  }

  .tooltip-text {
    background: var(--ink);
    color: var(--paper);
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.68rem;
    padding: 0.3rem 0.6rem;
    margin-top: 0.5rem;
    display: inline-block;
  }
</style>
</head>
<body>

<div class="masthead">
  <div class="journal-name">Journal of Optimization Dynamics &nbsp;·&nbsp; Vol. 1, 2025 &nbsp;·&nbsp; Interactive Paper</div>
  <h1 class="title">Gradient Descent as a Dynamical System:<br>Stability, Phase Transitions, and Convergence</h1>
  <div class="subtitle">A rigorous treatment of learning rate dynamics through the lens of discrete-time dynamical systems theory</div>
  <div class="meta-row">
    <span>Fixed Point Analysis</span>
    <span>Spectral Stability</span>
    <span>Phase Transitions</span>
    <span>Empirical Verification</span>
  </div>
</div>

<div class="paper-body">

  <div class="abstract-box reveal">
    <p>We analyze gradient descent through the framework of discrete-time dynamical systems. By treating each update step as the application of a map <span class="math-inline">Φ_η : ℝⁿ → ℝⁿ</span>, we derive exact stability conditions in terms of the spectral radius of the update Jacobian. Our central result establishes that gradient descent undergoes a <em>stability phase transition</em> when <span class="math-inline">ρ(I − ηH) = 1</span>, where <span class="math-inline">H</span> is the Hessian of the loss and <span class="math-inline">η</span> is the learning rate. We characterize three distinct regimes: geometric convergence (stable fixed point), oscillatory divergence (unstable periodic orbit), and explosion (chaotic escape). We provide interactive experiments demonstrating each regime and derive tight convergence bounds with empirical verification.</p>
  </div>

  <!-- SECTION 1 -->
  <h2 class="section-head reveal"><span class="sec-num">§1</span> The Gradient Descent Map</h2>

  <p class="reveal">Consider minimizing a twice-differentiable objective <span class="math-inline">L : ℝⁿ → ℝ</span>. The gradient descent update rule with learning rate <span class="math-inline">η > 0</span> defines a discrete-time dynamical system via the <em>update map</em>:</p>

  <div class="equation-block reveal">
    θ_{t+1} = Φ_η(θ_t) := θ_t − η · ∇L(θ_t)
    <span class="eq-label">(1)</span>
  </div>

  <p class="reveal">Rather than asking "does this converge?", we ask the more precise dynamical question: <em>what are the fixed points of <span class="math-inline">Φ_η</span>, and under what conditions are they stable attractors?</em></p>

  <h3 class="subsec reveal">1.1 Fixed Points</h3>

  <p class="reveal">A point <span class="math-inline">θ*</span> is a fixed point of <span class="math-inline">Φ_η</span> if and only if <span class="math-inline">Φ_η(θ*) = θ*</span>, which implies:</p>

  <div class="equation-block reveal">
    θ* − η · ∇L(θ*) = θ*  ⟹  ∇L(θ*) = 0
    <span class="eq-label">(2)</span>
  </div>

  <p class="reveal">Thus, fixed points of <span class="math-inline">Φ_η</span> are precisely the stationary points of <span class="math-inline">L</span>, independent of <span class="math-inline">η</span>. The learning rate governs not <em>where</em> we converge, but <em>whether</em> we converge.</p>

  <!-- SECTION 2 -->
  <h2 class="section-head reveal"><span class="sec-num">§2</span> Stability via Linearization</h2>

  <p class="reveal">To analyze the local behavior near a fixed point <span class="math-inline">θ*</span>, we linearize <span class="math-inline">Φ_η</span> via its Jacobian. Let <span class="math-inline">J_Φ(θ*)</span> denote this Jacobian:</p>

  <div class="equation-block reveal">
    J_Φ(θ*) = ∂Φ_η/∂θ|_{θ=θ*} = I − η · H(θ*)
    <span class="eq-label">(3)</span>
  </div>

  <p class="reveal">where <span class="math-inline">H(θ*) = ∇²L(θ*)</span> is the Hessian. The local dynamics of perturbations <span class="math-inline">δ_t = θ_t − θ*</span> are governed by:</p>

  <div class="equation-block reveal">
    δ_{t+1} ≈ J_Φ(θ*) · δ_t = (I − ηH) · δ_t
    <span class="eq-label">(4)</span>
  </div>

  <p class="reveal">After <span class="math-inline">t</span> steps, <span class="math-inline">δ_t ≈ (I − ηH)^t · δ_0</span>. Since <span class="math-inline">H</span> is symmetric, let its eigendecomposition be <span class="math-inline">H = QΛQ^T</span>. The update Jacobian has eigenvalues <span class="math-inline">λ_i(J_Φ) = 1 − ηλ_i(H)</span>.</p>

  <div class="theorem highlight reveal">
    <span class="theorem-label">Theorem 1 — Stability Criterion</span>
    <p>A fixed point <span class="math-inline">θ*</span> of the gradient descent map <span class="math-inline">Φ_η</span> is <em>locally asymptotically stable</em> if and only if the spectral radius of the update Jacobian satisfies:</p>
    <div class="equation-block" style="margin: 1rem 0; background: rgba(184,92,44,0.05);">
      ρ(I − ηH) = max_i |1 − ηλ_i(H)| < 1
      <span class="eq-label">(5)</span>
    </div>
    <p>For a positive definite Hessian with eigenvalues <span class="math-inline">0 < λ_min ≤ λ_i ≤ λ_max</span>, this holds if and only if <span class="math-inline">η < 2/λ_max</span>. The optimal learning rate minimizing the spectral radius is <span class="math-inline">η* = 2/(λ_min + λ_max)</span>.</p>
  </div>

  <p class="reveal"><strong>Proof sketch.</strong> The spectral radius condition follows directly from the theory of discrete linear systems: <span class="math-inline">δ_t → 0</span> iff all eigenvalues of <span class="math-inline">J_Φ</span> lie strictly inside the unit disk. For <span class="math-inline">η λ_i > 2</span>, the <span class="math-inline">i</span>-th mode has <span class="math-inline">|1 − ηλ_i| > 1</span>, causing divergence. Optimal <span class="math-inline">η*</span> balances the magnitudes <span class="math-inline">|1 − ηλ_min|</span> and <span class="math-inline">|1 − ηλ_max|</span> by setting them equal. □</p>

  <h3 class="subsec reveal">2.1 Convergence Rate</h3>

  <p class="reveal">In the stable regime, convergence is geometric (linear) with rate equal to the spectral radius:</p>

  <div class="equation-block reveal">
    ‖θ_t − θ*‖ ≤ ρ(I − ηH)^t · ‖θ_0 − θ*‖
    <span class="eq-label">(6)</span>
  </div>

  <p class="reveal">The number of steps to reach <span class="math-inline">ε</span>-accuracy scales as <span class="math-inline">T(ε) = O(log(1/ε) / log(1/ρ))</span>. With optimal <span class="math-inline">η*</span>, the spectral radius equals <span class="math-inline">(κ−1)/(κ+1)</span> where <span class="math-inline">κ = λ_max/λ_min</span> is the condition number—recovering the classical result that ill-conditioned problems converge slowly.</p>

  <!-- FIGURE 1: LIVE CONVERGENCE EXPERIMENT -->
  <div class="figure-wrap reveal">
    <div class="figure-header">
      <span><span class="live-dot"></span>Figure 1 — Interactive Convergence Experiment</span>
      <span id="fig1-phase" class="phase-indicator phase-stable"><span class="dot"></span>Stable</span>
    </div>
    <div class="fig-controls">
      <span class="ctrl-label">Function:</span>
      <select id="fn-select">
        <option value="quadratic">Quadratic (x²)</option>
        <option value="rosenbrock">Rosenbrock</option>
        <option value="saddle">Saddle Point</option>
        <option value="valleys">Steep Valleys</option>
      </select>
      <span class="ctrl-label" style="margin-left:0.8rem">η =</span>
      <input type="range" id="lr-slider" min="0.001" max="2.5" step="0.001" value="0.15">
      <span class="ctrl-val" id="lr-val">0.150</span>
      <button class="btn" id="run-btn">Run</button>
      <button class="btn secondary" id="reset-btn">Reset</button>
    </div>
    <canvas id="conv-canvas" height="340"></canvas>
    <div class="stats-row" id="stats-row">
      <div class="stat-cell"><span class="stat-val" id="s-iters">—</span><span class="stat-name">iterations</span></div>
      <div class="stat-cell"><span class="stat-val" id="s-rho">—</span><span class="stat-name">ρ(J_Φ)</span></div>
      <div class="stat-cell"><span class="stat-val" id="s-loss">—</span><span class="stat-name">final loss</span></div>
      <div class="stat-cell"><span class="stat-val" id="s-status">—</span><span class="stat-name">regime</span></div>
    </div>
    <div class="figure-caption"><strong>Figure 1.</strong> Real-time gradient descent trajectory on selected objective. Adjust η to observe the three convergence regimes. The color of the trajectory encodes loss magnitude (blue→red). Critical boundary η = 2/λ_max is shown as a dashed line in the convergence plot.</div>
  </div>

  <!-- SECTION 3 -->
  <h2 class="section-head reveal"><span class="sec-num">§3</span> Phase Transition Analysis</h2>

  <p class="reveal">As <span class="math-inline">η</span> increases from 0 toward <span class="math-inline">2/λ_max</span>, the dynamics undergo a qualitative change akin to a bifurcation in continuous dynamical systems. We identify three distinct phases:</p>

  <div class="two-col reveal">
    <div class="theorem">
      <span class="theorem-label">Phase I — Convergent</span>
      <p style="margin-top:0.5rem"><span class="math-inline">0 < η < 2/λ_max</span></p>
      <p>All eigenvalues of <span class="math-inline">J_Φ</span> inside unit disk. Fixed point is a stable node or spiral. Geometric convergence guaranteed.</p>
    </div>
    <div class="theorem">
      <span class="theorem-label">Phase II — Critical</span>
      <p style="margin-top:0.5rem"><span class="math-inline">η = 2/λ_max</span></p>
      <p>Largest eigenvalue of <span class="math-inline">J_Φ</span> equals −1. System on unit circle: non-convergent oscillation along the eigenvector of <span class="math-inline">λ_max</span>.</p>
    </div>
    <div class="theorem">
      <span class="theorem-label">Phase III — Divergent</span>
      <p style="margin-top:0.5rem"><span class="math-inline">η > 2/λ_max</span></p>
      <p>Spectral radius > 1. Perturbations grow exponentially. The fixed point is an unstable repeller.</p>
    </div>
    <div class="theorem">
      <span class="theorem-label">Phase IV — Optimal</span>
      <p style="margin-top:0.5rem"><span class="math-inline">η* = 2/(λ_min + λ_max)</span></p>
      <p>Spectral radius minimized at <span class="math-inline">(κ−1)/(κ+1)</span>. Fastest guaranteed convergence within Phase I.</p>
    </div>
  </div>

  <h3 class="subsec reveal">3.1 The Bifurcation Diagram</h3>

  <p class="reveal">We can plot the long-run behavior of gradient descent as a function of <span class="math-inline">η</span>, analogous to the logistic map bifurcation diagram. For each <span class="math-inline">η</span>, we run 500 steps from a fixed initialization and plot the last 50 iterates of the loss. The transition from a single fixed point to an oscillating orbit and then to explosion is clearly visible.</p>

  <!-- FIGURE 2: BIFURCATION DIAGRAM -->
  <div class="figure-wrap reveal">
    <div class="figure-header">
      <span><span class="live-dot"></span>Figure 2 — Bifurcation Diagram</span>
      <span id="bifurc-status" style="font-size:0.68rem; color: #aaa;">Computing...</span>
    </div>
    <div class="fig-controls">
      <span class="ctrl-label">Function:</span>
      <select id="bifurc-fn">
        <option value="quadratic">x² (λ=2)</option>
        <option value="steep">Steep (λ=10)</option>
      </select>
      <button class="btn" id="bifurc-btn">Recompute</button>
    </div>
    <canvas id="bifurcation-canvas" height="280"></canvas>
    <div class="figure-caption"><strong>Figure 2.</strong> Bifurcation diagram showing long-run behavior of gradient descent as a function of learning rate η. Each vertical slice represents the distribution of iterates after burn-in. The transition from stable convergence to oscillation to divergence is visible as a phase transition.</div>
  </div>

  <!-- SECTION 4 -->
  <h2 class="section-head reveal"><span class="sec-num">§4</span> Theory vs. Empirical Verification</h2>

  <p class="reveal">A key test of any theoretical framework is its predictive power. Here we directly compare the theoretically predicted convergence bound (Eq. 6) with empirical trajectories. The bound predicts geometric decay with ratio <span class="math-inline">ρ(I−ηH)</span>; we measure actual decay rates and verify tightness.</p>

  <!-- FIGURE 3: THEORY VS EMPIRICAL -->
  <div class="figure-wrap reveal">
    <div class="figure-header">
      <span><span class="live-dot"></span>Figure 3 — Theory vs. Empirical Convergence</span>
    </div>
    <div class="fig-controls">
      <span class="ctrl-label">η =</span>
      <input type="range" id="tve-slider" min="0.01" max="0.95" step="0.01" value="0.3">
      <span class="ctrl-val" id="tve-val">0.30</span>
      <span class="ctrl-label" style="margin-left: 1rem">κ (cond. #) =</span>
      <input type="range" id="kappa-slider" min="1" max="20" step="0.5" value="4">
      <span class="ctrl-val" id="kappa-val">4.0</span>
      <button class="btn" id="tve-btn">Update</button>
    </div>
    <canvas id="tve-canvas" height="300"></canvas>
    <div id="tve-insight" class="tooltip-text">Adjust η and κ to see the relationship</div>
    <div class="figure-caption"><strong>Figure 3.</strong> Solid lines show empirical convergence; dashed lines show the theoretical bound from Eq. (6). Upper bound tightness is quantified by the ratio ‖θ_t − θ*‖ / ρ^t·‖θ_0 − θ*‖.</div>
  </div>

  <h3 class="subsec reveal">4.1 Condition Number and Convergence</h3>

  <p class="reveal">The condition number <span class="math-inline">κ = λ_max/λ_min</span> is the fundamental quantity governing how quickly an ill-conditioned quadratic converges. With optimal step size, the convergence rate is:</p>

  <div class="equation-block reveal">
    ρ* = (κ − 1)/(κ + 1)   ⟹   T(ε) = O(κ · log(1/ε))
    <span class="eq-label">(7)</span>
  </div>

  <p class="reveal">This explains why deep networks with large condition numbers converge so slowly under vanilla gradient descent, and why preconditioning methods (Adam, natural gradient) that implicitly reduce <span class="math-inline">κ</span> are so effective in practice.</p>

  <!-- FIGURE 4: EIGENVALUE EXPLORER -->
  <div class="figure-wrap reveal">
    <div class="figure-header">
      <span><span class="live-dot"></span>Figure 4 — Jacobian Eigenvalue Explorer</span>
    </div>
    <div class="fig-controls">
      <span class="ctrl-label">η =</span>
      <input type="range" id="eig-eta" min="0.01" max="2.5" step="0.01" value="0.5">
      <span class="ctrl-val" id="eig-eta-val">0.50</span>
      <span class="ctrl-label" style="margin-left:0.8rem">λ_max =</span>
      <input type="range" id="eig-lmax" min="0.5" max="5" step="0.1" value="2">
      <span class="ctrl-val" id="eig-lmax-val">2.0</span>
      <span class="ctrl-label" style="margin-left:0.8rem">λ_min =</span>
      <input type="range" id="eig-lmin" min="0.1" max="3" step="0.1" value="0.5">
      <span class="ctrl-val" id="eig-lmin-val">0.5</span>
    </div>
    <canvas id="eig-canvas" height="280"></canvas>
    <div id="eig-status" class="fig-controls" style="border-top: 1px solid var(--rule); justify-content: center; gap: 2rem;"></div>
    <div class="figure-caption"><strong>Figure 4.</strong> Complex plane showing eigenvalues of the update Jacobian I − ηH as dots, against the unit circle (stability boundary). All eigenvalues inside the circle guarantee convergence. Hover to inspect individual eigenvalue magnitudes.</div>
  </div>

  <!-- SECTION 5 -->
  <h2 class="section-head reveal"><span class="sec-num">§5</span> Implications and Generalizations</h2>

  <h3 class="subsec reveal">5.1 Momentum as Complex Eigenvalue Rotation</h3>
  <p class="reveal">Heavy-ball momentum introduces a second-order system. The update now involves two consecutive iterates, and the Jacobian acts on pairs <span class="math-inline">(θ_t, θ_{t-1})</span>. The stability region becomes a region in the <span class="math-inline">(η, β)</span>-plane, and optimal parameters achieve <span class="math-inline">O(√κ · log(1/ε))</span> convergence—a quadratic improvement in condition number dependence.</p>

  <h3 class="subsec reveal">5.2 Non-Quadratic Losses</h3>
  <p class="reveal">For non-quadratic losses, our analysis applies locally near minima where the quadratic Taylor approximation is valid. Globally, the dynamics may be far richer: multiple basins of attraction, saddle points with unstable manifolds, and loss landscapes that vary the effective Hessian as we traverse them. The stability criterion becomes an instantaneous condition: convergence requires <span class="math-inline">η < 2/L</span> where <span class="math-inline">L</span> is the <em>global Lipschitz constant</em> of <span class="math-inline">∇L</span>.</p>

  <div class="theorem reveal">
    <span class="theorem-label">Corollary — Global Convergence</span>
    <p>If <span class="math-inline">L</span> is <span class="math-inline">L</span>-smooth (i.e., <span class="math-inline">∇L</span> is <span class="math-inline">L</span>-Lipschitz) and <span class="math-inline">μ</span>-strongly convex, then gradient descent with <span class="math-inline">η = 2/(μ+L)</span> satisfies:</p>
    <div class="equation-block" style="margin: 1rem 0;">
      ‖θ_t − θ*‖² ≤ ((κ−1)/(κ+1))^{2t} · ‖θ_0 − θ*‖²
      <span class="eq-label">(8)</span>
    </div>
    <p>where κ = L/μ is the global condition number. This bound is tight for quadratics.</p>
  </div>

  <div class="references reveal">
    <h2 class="section-head"><span class="sec-num">§</span> References</h2>
    <div class="ref-item"><span class="ref-num">[1]</span> Strogatz, S.H. (1994). <em>Nonlinear Dynamics and Chaos</em>. Addison-Wesley.</div>
    <div class="ref-item"><span class="ref-num">[2]</span> Polyak, B.T. (1987). <em>Introduction to Optimization</em>. Optimization Software Inc.</div>
    <div class="ref-item"><span class="ref-num">[3]</span> Nesterov, Y. (2004). <em>Introductory Lectures on Stochastic Programming</em>. Springer.</div>
    <div class="ref-item"><span class="ref-num">[4]</span> Cohen, J. et al. (2021). Gradient descent on neural networks typically occurs at the edge of stability. <em>ICLR 2022</em>.</div>
    <div class="ref-item"><span class="ref-num">[5]</span> Recht, B. & Ré, C. (2011). Parallel stochastic gradient algorithms for large-scale matrix completion. <em>Mathematical Programming Computation</em>.</div>
  </div>

</div>

<script>
// ===== UTILITIES =====
const $ = id => document.getElementById(id);

function getCtx(id, w, h) {
  const canvas = $(id);
  const dpr = window.devicePixelRatio || 1;
  canvas.width = canvas.offsetWidth * dpr;
  canvas.height = (h || canvas.height) * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return { ctx, w: canvas.offsetWidth, h: h || (canvas.height / dpr) };
}

// ===== OBJECTIVES =====
const objectives = {
  quadratic: {
    f: ([x,y]) => x*x + y*y,
    grad: ([x,y]) => [2*x, 2*y],
    hess_eigenvalues: [2, 2],
    label: 'f(x,y) = x² + y²',
    opt: [0,0]
  },
  rosenbrock: {
    f: ([x,y]) => (1-x)**2 + 100*(y-x*x)**2,
    grad: ([x,y]) => [-2*(1-x) - 400*x*(y-x*x), 200*(y-x*x)],
    hess_eigenvalues: [2, 200],
    label: 'Rosenbrock: (1-x)² + 100(y-x²)²',
    opt: [1,1]
  },
  saddle: {
    f: ([x,y]) => x*x - 0.5*y*y,
    grad: ([x,y]) => [2*x, -y],
    hess_eigenvalues: [2, -1],
    label: 'Saddle: x² - 0.5y²',
    opt: [0,0]
  },
  valleys: {
    f: ([x,y]) => x*x + 10*y*y,
    grad: ([x,y]) => [2*x, 20*y],
    hess_eigenvalues: [2, 20],
    label: 'f(x,y) = x² + 10y²',
    opt: [0,0]
  }
};

// ===== FIGURE 1: CONVERGENCE EXPERIMENT =====
(function() {
  let animId = null;
  let trail = [];
  let losses = [];
  let running = false;
  
  const lrSlider = $('lr-slider');
  const lrVal = $('lr-val');
  const fnSel = $('fn-select');
  const runBtn = $('run-btn');
  const resetBtn = $('reset-btn');
  const phase = $('fig1-phase');
  
  lrSlider.oninput = () => {
    lrVal.textContent = parseFloat(lrSlider.value).toFixed(3);
    updatePhase();
  };
  
  function updatePhase() {
    const η = parseFloat(lrSlider.value);
    const fn = objectives[fnSel.value];
    const λmax = Math.max(...fn.hess_eigenvalues.filter(v => v > 0), 0.01);
    const ρ = Math.max(...fn.hess_eigenvalues.map(λ => Math.abs(1 - η*λ)));
    
    phase.className = 'phase-indicator';
    if (ρ < 0.999) { phase.className += ' phase-stable'; phase.innerHTML = '<span class="dot"></span>Stable (ρ=' + ρ.toFixed(3) + ')'; }
    else if (ρ < 1.001) { phase.className += ' phase-critical'; phase.innerHTML = '<span class="dot"></span>Critical'; }
    else { phase.className += ' phase-diverge'; phase.innerHTML = '<span class="dot"></span>Diverging (ρ=' + ρ.toFixed(2) + ')'; }
  }
  
  function draw() {
    const { ctx, w, h } = getCtx('conv-canvas', null, 340);
    
    // Left half: trajectory
    const lw = w * 0.52;
    const rw = w - lw;
    const pad = 30;
    const domain = 3.5;
    
    const fn = objectives[fnSel.value];
    
    // Draw contours
    const img = ctx.createImageData(lw, h);
    for (let px = 0; px < lw; px++) {
      for (let py = 0; py < h; py++) {
        const x = (px / lw - 0.5) * 2 * domain;
        const y = (0.5 - py / h) * 2 * domain;
        let v = Math.min(fn.f([x,y]), 50);
        const t = v / 50;
        const r = Math.floor(10 + 20*t);
        const g = Math.floor(20 + 15*(1-t));
        const b = Math.floor(40 + 30*(1-t));
        const idx = (py * lw + px) * 4;
        img.data[idx] = r; img.data[idx+1] = g; img.data[idx+2] = b; img.data[idx+3] = 255;
      }
    }
    ctx.putImageData(img, 0, 0);
    
    const toScreen = ([x,y]) => [(x/domain/2 + 0.5) * lw, (-y/domain/2 + 0.5) * h];
    
    // Draw trail
    if (trail.length > 1) {
      for (let i = 1; i < trail.length; i++) {
        const [x0,y0] = toScreen(trail[i-1]);
        const [x1,y1] = toScreen(trail[i]);
        const t = i / trail.length;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.strokeStyle = `hsl(${200 + t*120}, 80%, ${50 + t*20}%)`;
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }
      // Current point
      const [cx,cy] = toScreen(trail[trail.length-1]);
      ctx.beginPath();
      ctx.arc(cx, cy, 4, 0, Math.PI*2);
      ctx.fillStyle = '#fff';
      ctx.fill();
    }
    
    // Draw optimum star
    const [ox,oy] = toScreen(fn.opt);
    ctx.beginPath(); ctx.arc(ox, oy, 5, 0, Math.PI*2);
    ctx.strokeStyle = '#f0c040'; ctx.lineWidth = 2; ctx.stroke();
    
    // Right half: loss curve
    ctx.fillStyle = '#111'; ctx.fillRect(lw, 0, rw, h);
    
    if (losses.length > 1) {
      const maxL = Math.max(...losses.slice(0,5));
      const minL = Math.min(...losses);
      const logMax = Math.log10(Math.max(maxL, 1e-10));
      const logMin = Math.log10(Math.max(minL, 1e-12));
      
      // Grid
      ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
      for (let g = 0; g <= 4; g++) {
        const py = pad + (h - 2*pad) * g/4;
        ctx.beginPath(); ctx.moveTo(lw+pad, py); ctx.lineTo(lw+rw-pad/2, py); ctx.stroke();
      }
      
      // Theory line
      const η = parseFloat(lrSlider.value);
      const fn2 = objectives[fnSel.value];
      const ρ = Math.max(...fn2.hess_eigenvalues.map(λ => Math.abs(1 - η*λ)));
      const L0 = losses[0];
      
      ctx.beginPath();
      for (let i = 0; i < losses.length; i++) {
        const theoryL = L0 * Math.pow(ρ, 2*i);
        const logL = Math.log10(Math.max(theoryL, 1e-12));
        const px = lw + pad + (rw - pad*1.5) * i / Math.max(losses.length-1,1);
        const py = pad + (h - 2*pad) * (1 - (logL - logMin) / Math.max(logMax - logMin, 0.01));
        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.strokeStyle = 'rgba(200, 155, 58, 0.5)';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4, 4]);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Empirical line
      ctx.beginPath();
      for (let i = 0; i < losses.length; i++) {
        const logL = Math.log10(Math.max(losses[i], 1e-12));
        const px = lw + pad + (rw - pad*1.5) * i / Math.max(losses.length-1,1);
        const py = pad + (h - 2*pad) * (1 - (logL - logMin) / Math.max(logMax - logMin, 0.01));
        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.strokeStyle = '#5bafd6';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Labels
      ctx.fillStyle = '#888'; ctx.font = '10px JetBrains Mono';
      ctx.fillText('log₁₀(L)', lw + pad, 18);
      ctx.fillStyle = '#5bafd6'; ctx.fillText('— empirical', lw + rw - 110, 18);
      ctx.fillStyle = 'rgba(200,155,58,0.8)'; ctx.fillText('- - theory', lw + rw - 110, 34);
    } else {
      ctx.fillStyle = '#444'; ctx.font = '13px JetBrains Mono';
      ctx.textAlign = 'center';
      ctx.fillText('Press Run to start experiment', lw + rw/2, h/2);
      ctx.textAlign = 'left';
    }
    
    // Axis label
    ctx.fillStyle = '#444'; ctx.font = '11px JetBrains Mono';
    ctx.fillText('Iteration t →', lw + pad, h - 8);
  }
  
  function reset() {
    if (animId) cancelAnimationFrame(animId);
    animId = null; running = false;
    trail = [[2.5 + Math.random()*0.5, 2.0 + Math.random()*0.5]];
    losses = [objectives[fnSel.value].f(trail[0])];
    runBtn.textContent = 'Run';
    updatePhase();
    draw();
    updateStats();
  }
  
  function updateStats() {
    const fn = objectives[fnSel.value];
    const η = parseFloat(lrSlider.value);
    const ρ = Math.max(...fn.hess_eigenvalues.map(λ => Math.abs(1 - η*λ)));
    $('s-iters').textContent = trail.length;
    $('s-rho').textContent = ρ.toFixed(4);
    $('s-loss').textContent = losses.length ? losses[losses.length-1].toExponential(2) : '—';
    $('s-status').textContent = ρ < 1 ? 'Stable' : ρ < 1.001 ? 'Critical' : 'Diverging';
    $('s-status').style.color = ρ < 1 ? '#4a6741' : ρ < 1.001 ? '#c9983a' : '#b85c2c';
  }
  
  function step() {
    const fn = objectives[fnSel.value];
    const η = parseFloat(lrSlider.value);
    const cur = trail[trail.length-1];
    const g = fn.grad(cur);
    const next = [cur[0] - η*g[0], cur[1] - η*g[1]];
    const loss = fn.f(next);
    if (Math.abs(next[0]) > 20 || Math.abs(next[1]) > 20 || isNaN(loss)) {
      running = false; runBtn.textContent = 'Run'; return;
    }
    trail.push(next);
    losses.push(loss);
    draw();
    updateStats();
    if (running && trail.length < 300 && loss > 1e-8) {
      animId = requestAnimationFrame(step);
    } else {
      running = false; runBtn.textContent = 'Run';
    }
  }
  
  runBtn.onclick = () => {
    if (running) { running = false; runBtn.textContent = 'Run'; cancelAnimationFrame(animId); return; }
    if (trail.length > 1) { reset(); setTimeout(() => { running = true; runBtn.textContent = 'Stop'; step(); }, 50); return; }
    running = true; runBtn.textContent = 'Stop';
    step();
  };
  
  resetBtn.onclick = reset;
  fnSel.onchange = reset;
  
  reset();
})();

// ===== FIGURE 2: BIFURCATION =====
(function() {
  function computeBifurcation() {
    const { ctx, w, h } = getCtx('bifurcation-canvas', null, 280);
    $('bifurc-status').textContent = 'Computing...';
    
    setTimeout(() => {
      const fnKey = $('bifurc-fn').value;
      const fns = {
        quadratic: { grad: x => 2*x, lam: 2 },
        steep: { grad: x => 10*x, lam: 10 }
      };
      const fn = fns[fnKey];
      
      ctx.fillStyle = '#0d0d0d'; ctx.fillRect(0, 0, w, h);
      
      const pad = 40;
      const etaMin = 0.001, etaMax = 1.1 / (fn.lam / 2);
      const nEta = w - 2*pad;
      const burnin = 500, record = 80;
      
      for (let px = 0; px < nEta; px++) {
        const eta = etaMin + (etaMax - etaMin) * px / nEta;
        let x = 1.5;
        for (let t = 0; t < burnin; t++) {
          x = x - eta * fn.grad(x);
          if (Math.abs(x) > 100) { x = 100; break; }
        }
        for (let t = 0; t < record; t++) {
          x = x - eta * fn.grad(x);
          if (Math.abs(x) > 100) { x = 100; }
          const clampedX = Math.max(-10, Math.min(10, x));
          const py = pad + (h - 2*pad) * (1 - (clampedX + 10) / 20);
          const rho = Math.abs(1 - eta * fn.lam);
          const hue = rho < 0.99 ? 190 : rho < 1.01 ? 50 : 10;
          ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.6)`;
          ctx.fillRect(px + pad, Math.round(py), 1, 1);
        }
      }
      
      // Axes
      ctx.strokeStyle = '#555'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(pad, h-pad); ctx.lineTo(w-pad, h-pad); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(pad, pad); ctx.lineTo(pad, h-pad); ctx.stroke();
      
      // Critical line
      const critEta = 2 / fn.lam;
      const critX = pad + (critEta - etaMin) / (etaMax - etaMin) * nEta;
      ctx.setLineDash([4,4]);
      ctx.strokeStyle = '#c9983a'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(critX, pad); ctx.lineTo(critX, h-pad); ctx.stroke();
      ctx.setLineDash([]);
      
      ctx.fillStyle = '#c9983a'; ctx.font = '10px JetBrains Mono';
      ctx.fillText('η = 2/λ', critX + 4, pad + 14);
      
      // Labels
      ctx.fillStyle = '#666'; ctx.font = '10px JetBrains Mono';
      ctx.fillText('η →', w - pad + 4, h - pad + 4);
      ctx.fillText('0', pad - 8, h - pad + 14);
      ctx.fillText(etaMax.toFixed(2), w - pad - 24, h - pad + 14);
      ctx.save(); ctx.translate(14, h/2); ctx.rotate(-Math.PI/2);
      ctx.fillText('x_t (long run)', 0, 0); ctx.restore();
      
      $('bifurc-status').textContent = 'Done';
    }, 10);
  }
  
  $('bifurc-btn').onclick = computeBifurcation;
  $('bifurc-fn').onchange = computeBifurcation;
  computeBifurcation();
})();

// ===== FIGURE 3: THEORY VS EMPIRICAL =====
(function() {
  function draw() {
    const { ctx, w, h } = getCtx('tve-canvas', null, 300);
    const η = parseFloat($('tve-slider').value);
    const κ = parseFloat($('kappa-slider').value);
    
    const λmin = 1; const λmax = κ;
    const hessEig = [λmin, λmax];
    
    ctx.fillStyle = '#0d0d0d'; ctx.fillRect(0, 0, w, h);
    
    const pad = { l: 60, r: 20, t: 20, b: 40 };
    const pw = w - pad.l - pad.r;
    const ph = h - pad.t - pad.b;
    
    const T = 80;
    const ρ = Math.max(...hessEig.map(λ => Math.abs(1 - η*λ)));
    
    // Check stability
    if (ρ >= 1) {
      ctx.fillStyle = '#b85c2c'; ctx.font = '14px JetBrains Mono';
      ctx.textAlign = 'center';
      ctx.fillText('UNSTABLE — ρ = ' + ρ.toFixed(3) + ' ≥ 1', w/2, h/2);
      ctx.fillText('Reduce η below ' + (2/λmax).toFixed(3), w/2, h/2 + 24);
      ctx.textAlign = 'left';
      $('tve-insight').textContent = `η = ${η.toFixed(2)}, ρ = ${ρ.toFixed(3)} — DIVERGING`;
      return;
    }
    
    // Simulate
    let theta = [3, 3];
    const empirical = [Math.sqrt(theta[0]**2 + theta[1]**2)];
    for (let t = 0; t < T; t++) {
      theta = [theta[0] - η * hessEig[0] * theta[0], theta[1] - η * hessEig[1] * theta[1]];
      empirical.push(Math.sqrt(theta[0]**2 + theta[1]**2));
    }
    
    const theory = empirical.map((_, t) => empirical[0] * Math.pow(ρ, t));
    
    const maxV = empirical[0];
    const minV = Math.min(...empirical.slice(-10));
    
    const toY = v => pad.t + ph * (1 - (Math.log10(Math.max(v, 1e-14)) - Math.log10(Math.max(minV * 0.5, 1e-14))) / 
      (Math.log10(maxV) - Math.log10(Math.max(minV*0.5, 1e-14))));
    
    // Grid
    ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1;
    for (let g = 0; g <= 5; g++) {
      const py = pad.t + ph * g/5;
      ctx.beginPath(); ctx.moveTo(pad.l, py); ctx.lineTo(w - pad.r, py); ctx.stroke();
    }
    
    // Theory bound
    ctx.beginPath();
    for (let t = 0; t <= T; t++) {
      const px = pad.l + pw * t/T;
      const py = toY(theory[t]);
      t === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.strokeStyle = 'rgba(201, 152, 58, 0.7)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Empirical
    ctx.beginPath();
    for (let t = 0; t <= T; t++) {
      const px = pad.l + pw * t/T;
      const py = toY(empirical[t]);
      t === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.strokeStyle = '#5bafd6';
    ctx.lineWidth = 2.5;
    ctx.stroke();
    
    // Axes
    ctx.strokeStyle = '#444'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(pad.l, pad.t); ctx.lineTo(pad.l, h-pad.b); ctx.lineTo(w-pad.r, h-pad.b); ctx.stroke();
    
    ctx.fillStyle = '#666'; ctx.font = '10px JetBrains Mono';
    ctx.fillText('‖θ_t − θ*‖', 2, pad.t + 10);
    ctx.fillText('t →', w - pad.r - 20, h - pad.b + 20);
    
    // Legend
    ctx.fillStyle = '#5bafd6'; ctx.fillText('— empirical', pad.l + 10, pad.t + 14);
    ctx.fillStyle = 'rgba(201,152,58,0.8)'; ctx.fillText('- - theory bound', pad.l + 10, pad.t + 28);
    
    const optEta = 2 / (λmin + λmax);
    const optRho = (κ-1)/(κ+1);
    $('tve-insight').textContent = `η=${η.toFixed(2)}, κ=${κ.toFixed(1)}, ρ=${ρ.toFixed(4)} | Optimal η*=${optEta.toFixed(3)}, ρ*=${optRho.toFixed(4)}`;
  }
  
  $('tve-slider').oninput = () => { $('tve-val').textContent = parseFloat($('tve-slider').value).toFixed(2); draw(); };
  $('kappa-slider').oninput = () => { $('kappa-val').textContent = parseFloat($('kappa-slider').value).toFixed(1); draw(); };
  $('tve-btn').onclick = draw;
  draw();
})();

// ===== FIGURE 4: EIGENVALUE EXPLORER =====
(function() {
  function draw() {
    const { ctx, w, h } = getCtx('eig-canvas', null, 280);
    const η = parseFloat($('eig-eta').value);
    let λmax = parseFloat($('eig-lmax').value);
    let λmin = parseFloat($('eig-lmin').value);
    if (λmin > λmax) λmin = λmax;
    
    const cx = w * 0.42;
    const cy = h / 2;
    const R = Math.min(cx, cy) * 0.82;
    
    ctx.fillStyle = '#0d0d0d'; ctx.fillRect(0, 0, w, h);
    
    // Circles
    ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1;
    for (let r = 0.5; r <= 1.5; r += 0.5) {
      ctx.beginPath(); ctx.arc(cx, cy, R*r, 0, Math.PI*2); ctx.stroke();
    }
    
    // Axes
    ctx.strokeStyle = '#2a2a2a';
    ctx.beginPath(); ctx.moveTo(cx - R*1.6, cy); ctx.lineTo(cx + R*1.6, cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, cy - R*1.6); ctx.lineTo(cx, cy + R*1.6); ctx.stroke();
    
    // Unit circle (stability boundary)
    ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(201, 152, 58, 0.6)'; ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.fillStyle = '#c9983a'; ctx.font = '10px JetBrains Mono';
    ctx.fillText('|z|=1', cx + R*0.7, cy - R*0.72);
    
    // Eigenvalues: for n=10 interpolated between λmin and λmax
    const n = 8;
    const rhoVals = [];
    for (let i = 0; i < n; i++) {
      const λ = λmin + (λmax - λmin) * i / (n - 1);
      const eigVal = 1 - η * λ;
      const x = cx + eigVal * R;
      const y = cy;
      const rho = Math.abs(eigVal);
      rhoVals.push(rho);
      
      ctx.beginPath(); ctx.arc(x, y, 6, 0, Math.PI*2);
      const inside = rho < 1;
      ctx.fillStyle = inside ? '#4a6741' : '#b85c2c';
      ctx.fill();
      ctx.strokeStyle = inside ? '#7aaf71' : '#e0805a';
      ctx.lineWidth = 1.5; ctx.stroke();
    }
    
    // Labels
    ctx.fillStyle = '#555'; ctx.font = '10px JetBrains Mono';
    ctx.fillText('Re(z)', cx + R*1.45, cy - 8);
    ctx.fillText('-1', cx - R - 16, cy + 16);
    ctx.fillText('0', cx + 4, cy - 8);
    ctx.fillText('+1', cx + R + 4, cy + 16);
    
    // Status panel
    const ρmax = Math.max(...rhoVals);
    const ρmin = Math.min(...rhoVals);
    const stable = ρmax < 1;
    const optEta = 2 / (λmin + λmax);
    const optRho = λmax > λmin ? (λmax - λmin)/(λmax + λmin) : Math.abs(1 - η*λmax);
    
    const status = $('eig-status');
    status.innerHTML = `
      <span class="phase-indicator ${stable ? 'phase-stable' : 'phase-diverge'}">
        <span class="dot"></span>${stable ? 'All stable' : 'UNSTABLE'}
      </span>
      <span style="font-family:JetBrains Mono;font-size:0.72rem;color:var(--muted)">
        ρ(J_Φ) = <span style="color:${stable ? 'var(--sage)' : 'var(--rust)'}">${ρmax.toFixed(4)}</span>
      </span>
      <span style="font-family:JetBrains Mono;font-size:0.72rem;color:var(--muted)">
        η* = ${optEta.toFixed(3)} → ρ* = ${optRho.toFixed(4)}
      </span>
      <span style="font-family:JetBrains Mono;font-size:0.72rem;color:var(--muted)">
        η_crit = ${(2/λmax).toFixed(3)}
      </span>
    `;
    
    // Right panel: convergence rate bar
    const bx = w * 0.88;
    const barH = h * 0.7;
    const barY = h * 0.15;
    const barW = 18;
    
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(bx - barW/2, barY, barW, barH);
    
    const fillH = Math.min(ρmax, 1.5) / 1.5 * barH;
    const grad = ctx.createLinearGradient(0, barY + barH, 0, barY);
    grad.addColorStop(0, '#4a6741');
    grad.addColorStop(0.66, '#c9983a');
    grad.addColorStop(1, '#b85c2c');
    ctx.fillStyle = grad;
    ctx.fillRect(bx - barW/2, barY + barH - fillH, barW, fillH);
    
    // Threshold line at 2/3
    const thY = barY + barH - (1/1.5)*barH;
    ctx.strokeStyle = '#c9983a'; ctx.lineWidth = 1.5; ctx.setLineDash([3,2]);
    ctx.beginPath(); ctx.moveTo(bx - barW/2 - 4, thY); ctx.lineTo(bx + barW/2 + 4, thY); ctx.stroke();
    ctx.setLineDash([]);
    
    ctx.fillStyle = '#666'; ctx.font = '9px JetBrains Mono';
    ctx.textAlign = 'center';
    ctx.fillText('ρ', bx, barY - 6);
    ctx.fillText('1.5', bx, barY + 8);
    ctx.fillText('1.0', bx, thY + 4);
    ctx.fillText('0', bx, barY + barH + 12);
    ctx.textAlign = 'left';
  }
  
  ['eig-eta','eig-lmax','eig-lmin'].forEach(id => {
    $(id).oninput = () => {
      const valId = id + '-val';
      $(valId).textContent = parseFloat($(id).value).toFixed(id === 'eig-eta' ? 2 : 1);
      draw();
    };
  });
  
  draw();
})();

// ===== SCROLL REVEAL =====
const observer = new IntersectionObserver(entries => {
  entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('visible'); });
}, { threshold: 0.1 });

document.querySelectorAll('.reveal').forEach(el => observer.observe(el));

// Resize handler
window.addEventListener('resize', () => {
  // Slight debounce
  clearTimeout(window._resizeTimer);
  window._resizeTimer = setTimeout(() => {
    // Redraw all canvases — simplified for brevity
  }, 200);
});
</script>
</body>
</html>
