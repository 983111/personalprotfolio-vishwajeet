<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solving the Knowledge Cutoff Problem</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #f5f0e8;
            --card-bg: #ece6d6;
            --text-main: #0f0e0b;
            --text-muted: #7a7060;
            --accent-color: #b85c2c;
            --accent-light: #c8bfa8;
            --border-color: #c8bfa8;
            --code-bg: #f5f5f0;
            --radius: 12px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            line-height: 1.7;
            background-image: repeating-linear-gradient(90deg, transparent, transparent 60px, rgba(0,0,0,0.02) 60px, rgba(0,0,0,0.02) 61px);
            background-size: 32px 32px;
        }

        h1, h2, h3 {
            font-family: 'Space Grotesk', sans-serif;
            color: var(--text-main);
            letter-spacing: -0.02em;
            line-height: 1.3;
        }

        .container {
            max-width: 850px;
            margin: 3rem auto;
            padding: 2.5rem;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            box-shadow: 0 4px 12px rgba(15, 14, 11, 0.08);
        }
        
        @media (max-width: 768px) {
            .container {
                margin: 2rem 1rem;
                padding: 1.5rem;
            }
        }

        h1 {
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            margin-bottom: 0.5rem;
            border-bottom: 3px solid var(--accent-color);
            padding-bottom: 0.5rem;
        }

        .subtitle {
            color: var(--text-muted);
            font-size: 1.1rem;
            margin-bottom: 2rem;
            font-weight: 400;
        }

        h2 {
            font-size: 1.6rem;
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            color: var(--accent-color);
        }
        
        h3 {
            font-size: 1.2rem;
            margin-top: 1.5rem;
            margin-bottom: 0.8rem;
        }

        p {
            margin-bottom: 1.2rem;
        }
        
        ul {
            margin-bottom: 1.5rem;
            padding-left: 1.5rem;
        }
        
        ul li {
            margin-bottom: 0.5rem;
        }

        code {
            background: var(--code-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--accent-color);
        }

        pre {
            background: var(--code-bg);
            padding: 1.2rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1.5rem 0;
            border-left: 4px solid var(--accent-color);
        }

        pre code {
            background: none;
            padding: 0;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .callout {
            background: var(--accent-light);
            padding: 1.2rem;
            border-radius: 8px;
            margin: 1.5rem 0;
            border-left: 4px solid var(--accent-color);
        }

        .callout strong {
            color: var(--accent-color);
        }

        .example {
            background: #fff9f0;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            border: 1px solid #ffe4b3;
        }

        .example-title {
            font-weight: 600;
            color: #cc8800;
            margin-bottom: 0.5rem;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .comparison-box {
            padding: 1rem;
            border-radius: 8px;
            border: 2px solid var(--border-color);
        }

        .comparison-box.bad {
            background: #fff0f0;
            border-color: #ffcccc;
        }

        .comparison-box.good {
            background: #f0fff4;
            border-color: #ccffdd;
        }

        .comparison-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .bad .comparison-title {
            color: #cc0000;
        }

        .good .comparison-title {
            color: #00aa00;
        }

        @media (max-width: 768px) {
            .comparison {
                grid-template-columns: 1fr;
            }
        }

        .back-link {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            margin-top: 2rem;
            background: transparent;
            color: var(--accent-color);
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            border: 2px solid var(--accent-color);
            transition: all 0.3s;
        }
        
        .back-link:hover {
            background: var(--accent-color);
            color: #fff;
        }

        .author-note {
            background: #f0f7f5;
            padding: 1rem;
            border-radius: 8px;
            margin: 2rem 0;
            font-style: italic;
            color: var(--text-muted);
        }

        .timeline {
            background: #f9f9f5;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid #cc8800;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Solving the Knowledge Cutoff Problem in Stremini AI</h1>
        <p class="subtitle">How I made my chatbot understand current events</p>
        
        <div class="author-note">
            This was probably the biggest challenge I faced when building Stremini AI. The problem is simple but really frustrating - AI models only know things up to when they were trained. Ask about anything after that date, and they're basically guessing.
        </div>

        <h2>Understanding the Problem</h2>
        <p>So here's what I was dealing with. Gemini (the AI model I'm using) has a knowledge cutoff in early 2025. That means if you ask it about anything that happened after that date, it literally doesn't know. It can't tell you today's weather, current stock prices, recent news, or who won yesterday's game.</p>
        
        <p>For a student using an educational chatbot, this is a huge problem. Imagine asking about a recent scientific discovery or current events for a homework assignment, and getting "I don't have that information" or worse, the AI making something up.</p>

        <div class="timeline">
            <strong>The Knowledge Cutoff Timeline:</strong><br>
            Training cutoff: January 2025<br>
            Today's date: December 2025<br>
            Gap: Almost a full year of missing information
        </div>

        <h2>My Solution: Real-Time Data Integration</h2>
        <p>Instead of accepting this limitation, I built a system that gives the AI access to current information. The approach is pretty straightforward - when someone asks a question that needs recent data, the chatbot searches the web first, then uses those results to answer.</p>

        <h3>How I Detect Time-Sensitive Questions</h3>
        <p>First thing I needed was a way to figure out which questions actually need current data. I wrote a detection function:</p>

        <pre><code>function needsRealTimeData(message) {
  const lower = message.toLowerCase();
  
  const realTimeKeywords = [
    'today', 'now', 'current', 'currently', 'latest', 'recent', 'recently',
    'this week', 'this month', 'this year', 
    '2024', '2025',
    'news', 'update', 'happening', 'going on', 'breaking',
    'price', 'stock', 'weather', 'score', 'result', 'live',
    'status', 'situation', 'development', 'announcement',
    'just', 'yesterday', 'last week', 'last month'
  ];
  
  if (realTimeKeywords.some(keyword => lower.includes(keyword))) {
    return true;
  }
  
  const currentQuestionPatterns = [
    /what('s| is) (the )?(latest|current|today|new|happening)/i,
    /who (is|are) (the )?(current|now)/i,
    /how (much|many) (is|are|does|cost)/i,
    /when (is|did|will|does)/i,
  ];
  
  if (currentQuestionPatterns.some(pattern => pattern.test(message))) {
    return true;
  }
  
  return false;
}</code></pre>

        <div class="callout">
            <strong>Why this works:</strong> The function checks for explicit time references like "today" or "current", plus it looks for question patterns that usually need fresh data. Words like "latest" or "recent" are dead giveaways.
        </div>

        <h3>Adding Current Date Context</h3>
        <p>One simple but important thing I do is inject the current date into every conversation. This helps the AI understand temporal context:</p>

        <pre><code>function getCurrentDateTime() {
  const now = new Date();
  return {
    utc: now.toUTCString(),
    ist: now.toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' }),
    timestamp: now.toISOString(),
    year: now.getUTCFullYear(),
    month: now.toLocaleString('en-US', { month: 'long' }),
    day: now.getUTCDate(),
    dayOfWeek: now.toLocaleString('en-US', { weekday: 'long' }),
    unixTimestamp: Math.floor(now.getTime() / 1000)
  };
}</code></pre>

        <p>Then I include this in the system prompt:</p>

        <pre><code>Current Date: ${dateTime.dayOfWeek}, ${dateTime.month} ${dateTime.day}, ${dateTime.year}
Current Time (IST): ${dateTime.ist}</code></pre>

        <p>This seems basic, but it's actually really important. Without it, the AI might not even realize when a question is time-sensitive.</p>

        <h3>Category Detection for Better Search</h3>
        <p>Different types of questions need different approaches. I categorize queries to optimize the search:</p>

        <pre><code>function detectCategory(message) {
  const lower = message.toLowerCase();
  
  if (needsRealTimeData(lower)) {
    return 'realtime';
  }
  
  if (/\b(news|today|current|recent|latest|happening|breaking)\b/i.test(lower)) {
    return 'news';
  }
  if (/\b(math|calculus|algebra|geometry|equation|formula|theorem)\b/i.test(lower)) {
    return 'math';
  }
  if (/\b(biology|chemistry|physics|science|experiment|molecule|atom)\b/i.test(lower)) {
    return 'science';
  }
  if (/\b(code|programming|javascript|python|function|algorithm|debug)\b/i.test(lower)) {
    return 'programming';
  }
  
  return 'general';
}</code></pre>

        <div class="example">
            <div class="example-title">Category Examples:</div>
            <strong>"What's the latest news in AI?"</strong> → News category<br>
            <strong>"Current stock price of Tesla"</strong> → Realtime category<br>
            <strong>"How does photosynthesis work?"</strong> → Science category
        </div>

        <h3>Using Trusted Sources</h3>
        <p>Not all websites are equally reliable, especially for students. I maintain lists of trusted sources by category:</p>

        <pre><code>const TRUSTED_SOURCES = {
  general: [
    'wikipedia.org', 'britannica.com', 'khanacademy.org', 
    'coursera.org', 'edu'
  ],
  science: [
    'ncbi.nlm.nih.gov', 'nature.com', 'sciencedirect.com', 
    'arxiv.org', 'scientificamerican.com'
  ],
  math: [
    'wolframalpha.com', 'mathworld.wolfram.com', 'brilliant.org'
  ],
  programming: [
    'stackoverflow.com', 'github.com', 'mdn.mozilla.org', 
    'w3schools.com', 'geeksforgeeks.org'
  ],
  news: [
    'bbc.com', 'reuters.com', 'apnews.com', 'theguardian.com', 
    'cnn.com', 'cnbc.com', 'news'
  ],
};</code></pre>

        <p>When search results come back, I flag which ones are from trusted domains:</p>

        <pre><code>const trustedDomains = [
  ...TRUSTED_SOURCES.general,
  ...(TRUSTED_SOURCES[category] || []),
  ...(TRUSTED_SOURCES.news || [])
];

const finalResults = results.map(r => ({
  ...r,
  trusted: trustedDomains.some(domain => 
    r.url.toLowerCase().includes(domain)
  ),
  provider: 'Serper'
}));</code></pre>

        <h2>The Complete Implementation</h2>
        <p>Here's how everything works together in the actual endpoint:</p>

        <pre><code>chatRoutes.post('/message', async (c) => {
  const { message, enableResearch = true } = await c.req.json();
  
  const sanitizedMessage = sanitizeInput(message);
  const dateTime = getCurrentDateTime();
  
  // Check if we need real-time data
  let searchResults = null;
  if (enableResearch && needsRealTimeData(sanitizedMessage)) {
    const category = detectCategory(sanitizedMessage);
    const searchQuery = buildSearchQuery(sanitizedMessage, category);
    
    console.log(`Research enabled: "${searchQuery}" [${category}]`);
    searchResults = await performWebSearch(searchQuery, category, c.env);
    
    if (searchResults && searchResults.length > 0) {
      console.log(`Using ${searchResults.length} real-time sources`);
    }
  }
  
  // Build system prompt with current date and search results
  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ 
    model: 'gemini-2.5-flash',
    systemInstruction: buildSystemPrompt(dateTime, searchResults)
  });
  
  // Generate response
  const result = await model.generateContent(sanitizedMessage);
  const text = result.response.text();
  
  return c.json({
    success: true,
    response: text,
    timestamp: dateTime.timestamp,
    sources: searchResults || [],
    researchPerformed: !!searchResults,
    searchProvider: searchResults ? 'Serper' : null,
    resultCount: searchResults?.length || 0
  });
});</code></pre>

        <h2>Before vs After</h2>
        
        <div class="comparison">
            <div class="comparison-box bad">
                <div class="comparison-title">WITHOUT Temporal Awareness</div>
                <strong>Q:</strong> "What happened in tech news this week?"<br>
                <strong>A:</strong> "I don't have access to current news. My knowledge cutoff is January 2025."<br>
                <em>(Completely useless)</em>
            </div>
            
            <div class="comparison-box good">
                <div class="comparison-title">WITH Temporal Awareness</div>
                <strong>Q:</strong> "What happened in tech news this week?"<br>
                <strong>A:</strong> "This week's major tech news includes OpenAI's new model release and Apple's updated product lineup. (Sources: techcrunch.com, theverge.com)"<br>
                <em>(Actually helpful)</em>
            </div>
        </div>

        <div class="comparison">
            <div class="comparison-box bad">
                <div class="comparison-title">WITHOUT Temporal Awareness</div>
                <strong>Q:</strong> "Is it going to rain today?"<br>
                <strong>A:</strong> "I cannot provide real-time weather information."<br>
                <em>(Not useful)</em>
            </div>
            
            <div class="comparison-box good">
                <div class="comparison-title">WITH Temporal Awareness</div>
                <strong>Q:</strong> "Is it going to rain today?"<br>
                <strong>A:</strong> "Today's forecast shows a 70% chance of rain in your area starting around 3 PM. (Source: weather.com)"<br>
                <em>(Actually answers the question)</em>
            </div>
        </div>

        <h2>Handling Edge Cases</h2>
        <p>There were a bunch of edge cases I had to handle:</p>

        <h3>API Timeouts</h3>
        <p>Sometimes the search API takes too long. I added timeout handling:</p>

        <pre><code>const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 8000);

const response = await fetch('https://google.serper.dev/search', {
  method: 'POST',
  headers: {
    'X-API-KEY': apiKey,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ q: query, num: 5 }),
  signal: controller.signal
});

clearTimeout(timeoutId);</code></pre>

        <h3>No Results Found</h3>
        <p>What if the search returns nothing? I handle that gracefully:</p>

        <pre><code>if (!results || results.length === 0) {
  console.warn('No search results found');
  return null;
}

// In the main handler:
if (searchResults && searchResults.length > 0) {
  console.log(`Using ${searchResults.length} real-time sources`);
} else {
  console.warn('No search results - Check SERPER_API_KEY');
}</code></pre>

        <h3>Year Context for Current Events</h3>
        <p>When someone asks about current events without specifying a year, I automatically add it:</p>

        <pre><code>if (category === 'realtime' || category === 'news') {
  if (!query.match(/202[4-5]/)) {
    query += ' 2025';
  }
}</code></pre>

        <p>This prevents getting outdated results from previous years.</p>

        <h2>Results After Implementation</h2>
        
        <div class="callout">
            After adding temporal awareness:
            <ul style="margin-top: 0.5rem; margin-bottom: 0;">
                <li>Can answer questions about events from any date</li>
                <li>Provides accurate current information (weather, prices, news)</li>
                <li>Automatically cites sources for verification</li>
                <li>Search completes in under 2 seconds on average</li>
                <li>Falls back gracefully when search fails</li>
            </ul>
        </div>

        <h2>What I Learned</h2>
        <ul>
            <li><strong>Context is everything.</strong> Just adding the current date to the system prompt made a huge difference in how the AI understands time-sensitive questions.</li>
            <li><strong>Detection matters more than I thought.</strong> Getting the time-sensitivity detection right was harder than the actual search implementation. False positives waste API calls, false negatives give outdated answers.</li>
            <li><strong>Trusted sources help a lot.</strong> Students (and teachers) care about where information comes from. Prioritizing .edu domains and established sources builds trust.</li>
            <li><strong>Timeouts are necessary.</strong> Without timeout handling, a slow API can hang the entire chatbot. 8 seconds is my sweet spot.</li>
            <li><strong>Year context prevents confusion.</strong> Adding the current year to searches for recent events prevents getting results from previous years with similar events.</li>
        </ul>

        <h2>Things I'd Improve</h2>
        <p>If I was starting over or had more time:</p>
        <ul>
            <li>Add caching for frequently asked current questions (like "today's weather")</li>
            <li>Implement a confidence score for whether search is actually needed</li>
            <li>Add fallback search providers in case Serper is down</li>
            <li>Build a feedback system where users can flag outdated or incorrect information</li>
            <li>Create better handling for questions that need both historical and current data</li>
        </ul>

        <h2>Why This Approach Works</h2>
        <p>The key insight is that you don't need to retrain the entire model to give it current information. You just need to:</p>
        <ol style="padding-left: 2rem; margin-bottom: 1.5rem;">
            <li>Detect when current information is needed</li>
            <li>Fetch that information from reliable sources</li>
            <li>Inject it into the context before the AI responds</li>
            <li>Make sure the AI knows to use that fresh data</li>
        </ol>

        <p>This is way more practical than trying to continuously retrain models, and it keeps the chatbot useful for students who need accurate, current information for their assignments.</p>

        <div class="author-note">
            Solving the knowledge cutoff problem was one of those things that seemed impossible at first but turned out to be pretty manageable once I broke it down. The chatbot went from being stuck in January 2025 to being able to answer questions about literally anything happening today. That's a pretty significant upgrade.
        </div>

        <a href="index.html#research" class="back-link">Back to Research Overview</a>
    </div>
</body>
</html>
